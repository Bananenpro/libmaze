# Quick Start

### Scope
This quick start guide will show you how you can generate, manipulate, export and finally load a maze.

### The Maze class
All mazes are represented using the [Maze](Maze.md) class.
A simple maze can be instantiated using the following code:
```c++
#include "maze.h"

int main()
{
// Construct a maze with width 100 and height 50 (in cells)
Maze maze(100, 50);
}
```

**NOTE:** For better readability the main method won't be shown in the following examples.

Additionally an entrance and an exit position can be supplied:
```c++
#include "maze.h"

// Construct a maze with width 100, height 50, entrance position 30 and exit position 60 (in cells)
Maze maze(100, 50, 30, 60);
```


A maze object can be accessed or edited using two coordinate systems or 'grids': The *complete grid* and the *cell grid*.
More info can be found [here](Maze.md#different-grid-types).

Making use of this knowledge you can manipulate all mazes to your liking:

```c++
#include "maze.h"

// Construct a maze with width 100 and height 50 (in cells)
Maze maze(100, 50);

// true for active and false for inactive
bool cellActive {maze.get({0, 0}, GridType::CELLS)};

// make cell (0|0) active
maze.set({0, 0}, GridType::CELLS, true);

// true if right wall of cell (0|0) is open
bool wallOpen {maze.getWallOfCell({0, 0}, Direction::RIGHT)};

// open right wall of cell (0|0)
maze.setWallOfCell({0, 0}, Direction::RIGHT, true);
```

More examples and explanations about manipulating maze data are given [here](Maze.md#accessing-and-changing-data).

### Generating a maze
Mazes can be generated by passing an implementation of the [IGenerator interface](generators/Generator.md) to the
`void generate(IGenerator& generator)` member function:

```c++
#include "maze.h"
#include "generators/depth-first_generator.h"

Maze maze(100, 50);

DepthFirstGenerator generator;

// Generate the maze using the depth-first search algorithm
// This operation will override all existing contents of the maze
maze.generate(generator);
```

### Exporting a maze
Mazes can be saved by passing an implementation of the [IExporter interface](exporters/Exporter.md)
and the desired file path to the\
`void save(IExporter& exporter, const std::string& path) const`\
member function:

```c++
#include "maze.h"
#include "exporters/png_exporter.h"

Maze maze(100, 50);

PNGExporter exporter;

// Save the maze as a png file to the file 'maze.png'
maze.save(exporter, "maze.png");
```

### Loading a maze
Mazes can be loaded by passing an implementation of the [ILoader interface](loaders/Loader.md)
and the desired file path to the static\
`static Maze load(ILoader& loader, const std::string& path)`\
member function:
```c++
#include "maze.h"
#include "loaders/png_loader.h"


PNGLoader loader;

// Load the maze from the png file 'maze.png' into the maze variable
Maze maze {Maze::load(loader, "maze.png")};
```


### Additional topics
These are some other important topics outside the scope of this quick start guide:
- [Maze](Maze.md) for additional information about the maze class
- [ProgressReporter](ProgressReporter.md) for receiving progress callbacks for most operations

---
[Go to home](Home.md)\
Copyright Â© Julian Hofmann
